#!/usr/bin/env python3
import csv
import sys
import os
import argparse

def sanitize_alias(name):
    """Replaces hyphens and spaces with underscores for PlantUML aliases."""
    return name.replace("-", "_").replace(" ", "_")

def main():
    parser = argparse.ArgumentParser(
        description="Generate a PlantUML sequence diagram from a pvrrenumi.sh generated CSV."
    )
    
    # Mandatory Positional Argument
    parser.add_argument(
        "csv_file", 
        help="The CSV file generated by pvrrenumi.sh"
    )

    # Mandatory Option
    parser.add_argument(
        "--folder-path", 
        required=True, 
        help="Absolute path to the folder containing the JSON files (must start with /)."
    )

    # Optional participants
    parser.add_argument(
        "--from", 
        dest="from_participant", 
        default="a2ui-client", 
        help="Display name for the 'from' participant (default: a2ui-client)"
    )
    parser.add_argument(
        "--to", 
        dest="to_participant", 
        default="a2ui-source", 
        help="Display name for the 'to' participant (default: a2ui-source)"
    )

    args = parser.parse_args()

    # 1. Validate that folder-path is absolute
    if not os.path.isabs(args.folder_path):
        print(f"Error: --folder-path must be an absolute path (starting with /). Provided: {args.folder_path}", file=sys.stderr)
        sys.exit(1)

    # 2. Check if CSV file exists
    if not os.path.isfile(args.csv_file):
        print(f"Error: CSV file '{args.csv_file}' not found.", file=sys.stderr)
        sys.exit(1)

    # 3. Setup Aliases
    from_display = args.from_participant
    to_display = args.to_participant
    from_alias = sanitize_alias(from_display)
    to_alias = sanitize_alias(to_display)

    # 4. Generate PlantUML
    puml = []
    puml.append("@startuml")
    puml.append("skinparam svgLinkTarget my_display_frame")
    puml.append("")
    puml.append(f'participant "{from_display}" as {from_alias}')
    puml.append(f'participant "{to_display}" as {to_alias}')
    puml.append("")

    try:
        with open(args.csv_file, mode='r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                msg_type = row['MSGTYPE'].strip().upper()
                from_ip_port = f"{row['FROMIP']}:{row['FROMPORT']}"
                to_ip_port = f"{row['TOIP']}:{row['TOPORT']}"
                filename = row['FILENAME'].strip()
                bodyfilename = row['HTTPBODYFILENAME'].strip()
                
                # Construct the file:/// URL
                # Ensure no double slashes if folder_path ends in /
                full_path = os.path.join(args.folder_path, filename)
                file_url = f"file://{full_path}"
                full_path = os.path.join(args.folder_path, bodyfilename)
                bodyfile_url = f"file://{full_path}"

                if msg_type == "REQ":
                    caption = f"{row['METHOD']} {row['URI']}"
                    puml.append(f"note left of {from_alias} : {from_ip_port}")
                    puml.append(f"{from_alias} -> {to_alias} : [[{file_url} {caption}]]  [[{bodyfile_url} body]]")
                    puml.append(f"note right of {to_alias} : {to_ip_port}")
                
                elif msg_type == "RSP":
                    # Ensure RESPCODE is handled cleanly (no .0 if it's a float)
                    code = row['RESPCODE'].split('.')[0] if '.' in row['RESPCODE'] else row['RESPCODE']
                    caption = f"{code} {row['RESPPHRASE']}"
                    puml.append(f"note right of {to_alias} : {from_ip_port}")
                    puml.append(f"{to_alias} -> {from_alias} : [[{file_url} {caption}]]  [[{bodyfile_url} body]]")
                    puml.append(f"note left of {from_alias} : {to_ip_port}")
                
                puml.append("") # Spacer for readability

    except Exception as e:
        print(f"Error processing CSV: {e}", file=sys.stderr)
        sys.exit(1)

    puml.append("@enduml")

    # Output to stdout
    print("\n".join(puml))

if __name__ == "__main__":
    main()
